<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magical Christmas Tree & Fireworks v14</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #02040c; font-family: 'Times New Roman', serif; user-select: none; }
        
        /* 1. Scene Layers */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #fireworks-canvas { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 2; pointer-events: none; }
        
        /* 2. UI Layer (Title) */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; pointer-events: none;
            display: flex; flex-direction: column; 
            align-items: center;
            padding-top: 5vh;
            box-sizing: border-box;
            transition: opacity 1s;
        }

        h1 { 
            color: #fceea7; font-size: min(8vw, 56px); margin: 0; font-weight: 400; 
            letter-spacing: 6px; 
            text-shadow: 0 0 50px rgba(252, 238, 167, 0.6); 
            background: linear-gradient(to bottom, #fff, #eebb66);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-family: 'Cinzel', 'Times New Roman', serif;
            opacity: 0.9;
            text-align: center;
            padding: 0 20px;
        }

        /* 3. Overlay Screens */
        .fullscreen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(2, 4, 12, 0.95); 
            z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #d4af37;
            transition: opacity 0.8s ease;
            backdrop-filter: blur(10px);
        }

        /* Setup Box */
        .setup-container {
            width: 90%; max-width: 400px;
            padding: 30px;
            border: 1px solid rgba(212, 175, 55, 0.3);
            background: rgba(20, 20, 20, 0.6);
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        .setup-group { margin-bottom: 20px; text-align: left; }
        .setup-label { display: block; margin-bottom: 8px; font-size: 12px; letter-spacing: 2px; text-transform: uppercase; color: #888; }
        .setup-input { 
            width: 100%; padding: 10px; background: rgba(255,255,255,0.05); 
            border: 1px solid #444; color: #fff; font-family: inherit; box-sizing: border-box;
            border-radius: 4px;
        }
        .file-input-wrapper { position: relative; overflow: hidden; display: inline-block; width: 100%; }
        .file-btn {
            border: 1px solid rgba(212, 175, 55, 0.5); color: #d4af37; background: transparent;
            padding: 12px; width: 100%; cursor: pointer; transition: 0.3s;
            text-transform: uppercase; font-size: 11px; letter-spacing: 2px;
            border-radius: 4px;
            display: block; text-align: center; box-sizing: border-box;
        }
        .file-btn:hover { background: rgba(212, 175, 55, 0.1); }
        .file-btn.selected { background: rgba(212, 175, 55, 0.8); color: #000; }
        
        .action-btn {
            background: #d4af37; color: #000; border: none; padding: 15px 40px;
            font-size: 16px; letter-spacing: 4px; text-transform: uppercase;
            cursor: pointer; margin-top: 20px; font-weight: bold;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            border-radius: 4px;
        }
        .action-btn:hover { box-shadow: 0 0 50px rgba(212, 175, 55, 0.6); }
        .action-btn:active { transform: scale(0.95); }
        
        /* 确保按钮可点击 */
        .action-btn, .file-btn { 
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            cursor: pointer;
        }

        #init-btn { display: none; margin-top: 30px; }

        /* Webcam hidden */
        #webcam-wrapper {
            position: absolute; bottom: 20px; right: 20px; width: 100px; height: 75px;
            opacity: 0; pointer-events: none; z-index: 50;
            border: 1px solid rgba(255,255,255,0.2);
            transition: opacity 0.5s;
            border-radius: 4px; overflow: hidden;
        }

        .spinner { width: 40px; height: 40px; border: 2px solid rgba(212, 175, 55, 0.2); border-top: 2px solid #d4af37; border-radius: 50%; animation: spin 1s infinite linear; margin-bottom: 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loader-text { font-size: 12px; letter-spacing: 3px; text-transform: uppercase; color: #888; text-align: center; line-height: 1.5; }

    </style>
    <style>@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');</style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- 1. SYSTEM LOADER & PERMISSION -->
    <div id="system-loader" class="fullscreen-overlay" style="z-index: 200;">
        <div class="spinner" id="sys-spinner"></div>
        <div class="loader-text" id="sys-status">正在加载3D资源...</div>
        <button id="init-btn" class="action-btn" onclick="requestPermissionAndNext()" ontouchend="requestPermissionAndNext()">初始化 & 允许摄像头</button>
    </div>

    <!-- 2. SETUP SCREEN -->
    <div id="setup-screen" class="fullscreen-overlay" style="z-index: 150; display: none;">
        <div class="setup-container">
            <h2 style="font-family: 'Cinzel'; margin-bottom: 30px; font-weight: 400;">节日设置</h2>
            
            <div class="setup-group">
                <label class="setup-label">祝福语</label>
                <input type="text" id="greeting-input" class="setup-input" placeholder="圣诞快乐" value="圣诞快乐" maxlength="25">
            </div>

            <div class="setup-group">
                <label class="setup-label">添加照片（可多选）</label>
                <div class="file-input-wrapper">
                    <label class="file-btn" id="photo-btn" for="photo-input">选择图片</label>
                    <input type="file" id="photo-input" multiple accept="image/*" style="display: none;" onchange="handleSetupFiles(this, 'photo-btn')">
                </div>
            </div>

            <div class="setup-group">
                <label class="setup-label">背景音乐</label>
                <div class="file-input-wrapper">
                    <label class="file-btn" id="music-btn" for="music-input">选择音乐</label>
                    <input type="file" id="music-input" accept="audio/*" style="display: none;" onchange="handleSetupFiles(this, 'music-btn')">
                </div>
            </div>

            <button class="action-btn" onclick="finishSetupAndReveal()" ontouchend="finishSetupAndReveal()">开始魔法</button>
        </div>
    </div>

    <!-- MAIN SCENE -->
    <div id="canvas-container"></div>
    <canvas id="fireworks-canvas"></canvas>

    <div id="ui-layer">
        <h1 id="main-title">圣诞快乐</h1>
    </div>

    <!-- WEBCAM -->
    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline style="display:none;"></video>
        <canvas id="webcam-preview"></canvas>
    </div>

    <script>
        // --- GLOBAL VARIABLES ---
        let userPhotos = [];
        let userAudio = null;
        let isCameraReady = false;
        let globalStream = null; 

        // --- PHASE 1: PRELOAD ON LOAD ---
        window.onload = () => {
            // Start 3D Engine IMMEDIATELY in background
            if (window.startThreeEngine) window.startThreeEngine();

            // UI Logic
            const status = document.getElementById('sys-status');
            const btn = document.getElementById('init-btn');
            const spinner = document.getElementById('sys-spinner');

            status.innerHTML = "欢迎！<br>请点击下方按钮启用摄像头<br>获得完整的沉浸式体验。";
            spinner.style.display = 'none';
            btn.style.display = 'block';
        };

        // --- PHASE 2: PERMISSION ---
        async function requestPermissionAndNext() {
            const status = document.getElementById('sys-status');
            const btn = document.getElementById('init-btn');
            const spinner = document.getElementById('sys-spinner');

            btn.style.display = 'none';
            spinner.style.display = 'block';
            status.innerText = "正在请求摄像头权限...";

            try {
                // Keep the stream open!
                globalStream = await navigator.mediaDevices.getUserMedia({ video: true });
                isCameraReady = true;
                status.innerText = "摄像头权限已获取！";
                
                // Initialize MediaPipe logic now, using the SAVED stream
                if(window.initMediaPipeModule) window.initMediaPipeModule(globalStream);

            } catch (e) {
                console.warn("Camera denied:", e);
                isCameraReady = false;
                status.innerText = "已跳过摄像头，鼠标控制已启用。";
            }

            // Transition to Setup
            setTimeout(() => {
                document.getElementById('system-loader').style.display = 'none';
                document.getElementById('setup-screen').style.display = 'flex';
            }, 800);
        }

        // --- PHASE 3: SETUP & REVEAL ---
        function handleSetupFiles(input, btnId) {
            const btn = document.getElementById(btnId);
            if(input.files && input.files.length > 0) {
                btn.classList.add('selected');
                btn.textContent = `已选择 ${input.files.length} 个文件`;
                if(btnId === 'photo-btn') {
                    userPhotos = [];
                    const files = Array.from(input.files);
                    let loadedCount = 0;
                    files.forEach(file => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                userPhotos.push({
                                    src: e.target.result,
                                    aspect: img.width / img.height
                                });
                                loadedCount++;
                                btn.textContent = `已加载 ${loadedCount}/${files.length} 张图片`;
                            };
                            img.onerror = () => {
                                loadedCount++;
                                console.error('图片加载失败');
                            };
                            img.src = e.target.result;
                        };
                        reader.onerror = () => {
                            console.error('文件读取失败');
                        };
                        reader.readAsDataURL(file);
                    });
                } else if (btnId === 'music-btn') {
                    userAudio = input.files[0];
                }
            }
        }

        function finishSetupAndReveal() {
            // 1. Update Title
            const greeting = document.getElementById('greeting-input').value.trim() || "Merry Christmas";
            document.getElementById('main-title').innerText = greeting;

            // 2. Inject Photos into Running Scene
            if (userPhotos.length > 0 && window.addPhotosToRunningScene) {
                window.addPhotosToRunningScene(userPhotos);
            }

            // 3. Play Audio
            if(userAudio) {
                const audioUrl = URL.createObjectURL(userAudio);
                const audio = new Audio(audioUrl);
                audio.loop = true;
                audio.volume = 0.5;
                audio.play().catch(e => console.log("Audio play failed:", e));
            }

            // 4. Reveal
            const setupScreen = document.getElementById('setup-screen');
            setupScreen.style.opacity = 0;
            setTimeout(() => {
                setupScreen.style.display = 'none';
                // Activate interaction logic in 3D module
                if(window.activateInteraction) window.activateInteraction();
                // Show Webcam box if enabled
                if(isCameraReady) document.getElementById('webcam-wrapper').style.opacity = 0.5;
            }, 800);
        }

        window.addEventListener('keydown', (e) => {
            if(e.key.toLowerCase() === 'r') location.reload();
        });
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; 
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';

        // --- FIREWORKS ---
        const fwCanvas = document.getElementById('fireworks-canvas');
        const fwCtx = fwCanvas.getContext('2d');
        let fwWidth, fwHeight, fwScale;
        let particles = [];
        let smokes = [];
        
        const glowCanvas = document.createElement('canvas'); glowCanvas.width = 32; glowCanvas.height = 32;
        const gCtx = glowCanvas.getContext('2d'); const gradG = gCtx.createRadialGradient(16, 16, 0, 16, 16, 16); gradG.addColorStop(0, 'rgba(255, 255, 255, 1)'); gradG.addColorStop(0.4, 'rgba(255, 255, 255, 0.2)'); gradG.addColorStop(1, 'rgba(255, 255, 255, 0)'); gCtx.fillStyle = gradG; gCtx.fillRect(0, 0, 32, 32);
        const smokeCanvas = document.createElement('canvas'); smokeCanvas.width = 128; smokeCanvas.height = 128;
        const smCtx = smokeCanvas.getContext('2d'); const smGrad = smCtx.createRadialGradient(64, 64, 0, 64, 64, 64); smGrad.addColorStop(0, 'rgba(160, 160, 170, 0.8)'); smGrad.addColorStop(0.3, 'rgba(120, 120, 130, 0.3)'); smGrad.addColorStop(1, 'rgba(80, 80, 90, 0)'); smCtx.fillStyle = smGrad; smCtx.fillRect(0, 0, 128, 128);
        
        const random = (min, max) => Math.random() * (max - min) + min;
        const SPEED_MOD = 0.7; 

        class Smoke { constructor(x, y) { this.x = x; this.y = y; this.vx = random(-0.25, 0.25) * fwScale * SPEED_MOD; this.vy = random(-0.15, 0.15) * fwScale * SPEED_MOD; this.size = random(20, 45) * fwScale; this.growth = random(0.15, 0.3) * fwScale * SPEED_MOD; this.life = random(60, 100) / SPEED_MOD; this.maxLife = this.life; this.alphaStart = random(0.15, 0.3); } update() { this.x += this.vx; this.y += this.vy; this.size += this.growth; this.life--; return this.life > 0; } draw() { const progress = this.life / this.maxLife; const currentAlpha = this.alphaStart * Math.pow(progress, 2.0); if (currentAlpha > 0.005) { fwCtx.save(); fwCtx.globalCompositeOperation = 'source-over'; fwCtx.globalAlpha = currentAlpha; const drawSize = this.size * 2; fwCtx.drawImage(smokeCanvas, this.x - drawSize/2, this.y - drawSize/2, drawSize, drawSize); fwCtx.restore(); } } }
        class Spark { constructor(x, y, vx, vy, isGlitter = false) { this.x = x; this.y = y; this.isGlitter = isGlitter; if (isGlitter) { this.vx = (vx * 0.1 + random(-0.5, 0.5) * fwScale) * SPEED_MOD; this.vy = (vy * 0.1 + random(-0.5, 0.5) * fwScale) * SPEED_MOD; this.friction = 0.92; this.gravity = 0.015 * fwScale * SPEED_MOD; this.life = random(60, 100) / SPEED_MOD; this.maxLife = this.life; this.size = random(1, 2.5) * fwScale; this.flickerSpeed = random(0.3, 0.6) * SPEED_MOD; } else { this.vx = (vx * 0.3 + random(-1.5, 1.5) * fwScale) * SPEED_MOD; this.vy = (vy * 0.3 + random(-1.5, 1.5) * fwScale) * SPEED_MOD; this.friction = 0.96; this.gravity = 0.06 * fwScale * SPEED_MOD; this.life = random(40, 80) / SPEED_MOD; this.maxLife = this.life; this.size = random(1, 3) * fwScale; this.flickerSpeed = random(0.1, 0.3) * SPEED_MOD; } this.flickerOffset = random(0, 100); } update() { this.vx *= this.friction; this.vy *= this.friction; this.vy += this.gravity; this.x += this.vx; this.y += this.vy; this.life -= 1; return this.life > 0; } draw() { const flicker = Math.abs(Math.sin(this.life * this.flickerSpeed + this.flickerOffset)); const baseAlpha = this.life / this.maxLife; let finalAlpha, r, g, b; if (this.isGlitter) { finalAlpha = baseAlpha * (0.3 + flicker * 0.7); r = 255; g = 255; b = 255; } else { finalAlpha = baseAlpha * (0.3 + flicker * 0.7); r = 255; g = 220; b = 150; if (this.life < 20) { g = 150; b = 50; } } fwCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${finalAlpha})`; fwCtx.beginPath(); fwCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2); fwCtx.fill(); } }
        class WillowParticle { constructor(x, y, angle, speed, colorType, depthScale) { this.x = x; this.y = y; this.vx = Math.cos(angle) * speed * SPEED_MOD; this.vy = Math.sin(angle) * speed * SPEED_MOD; this.friction = 0.94; this.gravity = 0.07 * fwScale * SPEED_MOD; this.life = random(180, 250) / SPEED_MOD; this.maxLife = this.life; this.trail = []; this.maxTrail = 20; this.colorType = colorType; this.depthScale = depthScale; this.width = (colorType === 'gold' ? 3.0 : 2.0) * fwScale * depthScale; } update() { this.trail.push({x: this.x, y: this.y}); if(this.trail.length > this.maxTrail) this.trail.shift(); this.vx *= this.friction; this.vy *= this.friction; this.vy += this.gravity; this.x += this.vx; this.y += this.vy; this.life--; if(this.life % 8 === 0) smokes.push(new Smoke(this.x, this.y)); return this.life > 0; } draw() { if(this.trail.length < 2) return; const progress = this.life / this.maxLife; const alpha = Math.min(1, progress * 3); fwCtx.beginPath(); fwCtx.moveTo(this.trail[0].x, this.trail[0].y); for(let i=1; i<this.trail.length; i++) fwCtx.lineTo(this.trail[i].x, this.trail[i].y); fwCtx.lineTo(this.x, this.y); fwCtx.lineCap = 'round'; fwCtx.lineWidth = this.width * alpha; let strokeStyle = `rgba(255, 240, 150, ${alpha})`; if(this.colorType === 'red') strokeStyle = `rgba(255, 80, 80, ${alpha})`; else if(this.colorType === 'blue') strokeStyle = `rgba(80, 180, 255, ${alpha})`; fwCtx.strokeStyle = strokeStyle; fwCtx.stroke(); if (progress > 0.05) { const s = this.width * 2.5; fwCtx.drawImage(glowCanvas, this.x - s/2, this.y - s/2, s, s); } } }
        class Shell { constructor(x, y, targetX, targetY, type, depthScale) { this.x = x; this.y = y; this.targetY = targetY; this.type = type; this.depthScale = depthScale; const g = 0.15 * fwScale * SPEED_MOD; const dy = y - targetY; const vy = Math.sqrt(2 * g * dy); const t = vy / g; const dx = targetX - x; const vx = dx / t; this.vx = vx; this.vy = -vy; this.gravity = g; this.isDead = false; } update() { this.vy += this.gravity; this.x += this.vx; this.y += this.vy; if (Math.random() > 0.7) smokes.push(new Smoke(this.x, this.y)); if (this.vy >= 0) { this.isDead = true; if(this.type === 'willow') explodeWillow(this.x, this.y, this.depthScale); else if(this.type === 'comet') explodeComet(this.x, this.y); for(let i=0; i<6; i++) smokes.push(new Smoke(this.x + random(-10,10), this.y + random(-10,10))); } return !this.isDead; } draw() { const size = 6 * fwScale * this.depthScale; fwCtx.drawImage(glowCanvas, this.x - size, this.y - size, size*2, size*2); fwCtx.beginPath(); fwCtx.moveTo(this.x, this.y); fwCtx.lineTo(this.x - this.vx*2.5, this.y - this.vy*2.5); fwCtx.lineCap = 'round'; fwCtx.strokeStyle = 'rgba(255, 200, 100, 0.3)'; fwCtx.lineWidth = 8 * fwScale; fwCtx.stroke(); fwCtx.beginPath(); fwCtx.moveTo(this.x, this.y); fwCtx.lineTo(this.x - this.vx*2.5, this.y - this.vy*2.5); fwCtx.strokeStyle = 'rgba(255, 255, 220, 0.95)'; fwCtx.lineWidth = 3 * fwScale; fwCtx.stroke(); } }

        function explodeWillow(x, y, depthScale) { const count = 80; const colors = ['gold', 'red', 'blue']; for(let i=0; i<count; i++) { const angle = random(0, Math.PI*2); const speed = random(5, 22) * fwScale * depthScale; const color = colors[Math.floor(Math.random() * colors.length)]; particles.push(new WillowParticle(x, y, angle, speed, color, depthScale)); } }
        function explodeComet(x, y) { for(let k=0; k<15; k++) { const ang = random(0, Math.PI*2); const spd = random(2, 8) * fwScale; particles.push(new Spark(x, y, Math.cos(ang)*spd, Math.sin(ang)*spd, true)); } }
        function resizeFireworks() { fwWidth = fwCanvas.width = window.innerWidth; fwHeight = fwCanvas.height = window.innerHeight; fwScale = Math.min(fwWidth, fwHeight) / 900; }
        function triggerChapter3Fireworks() {
            const cx = fwWidth / 2; const targetBaseY = fwHeight * 0.25; const spreadW = fwWidth * 0.6; const startX = cx - spreadW / 2; const stepX = spreadW / 4; 
            for(let i=0; i<5; i++) { const targetX = startX + stepX * i; const targetY = targetBaseY + random(-50, 50) * fwScale; const depth = random(0.8, 1.2); setTimeout(() => { particles.push(new Shell(cx, fwHeight, targetX, targetY, 'willow', depth)); }, i * 200); }
            setTimeout(() => { const groundY = fwHeight; for(let i=0; i<6; i++) { const x = (i < 3) ? (fwWidth * 0.15 + i*30*fwScale) : (fwWidth * 0.85 - (i-3)*30*fwScale); const tx = x + (i<3 ? 50 : -50)*fwScale; setTimeout(() => { particles.push(new Shell(x, groundY, tx, fwHeight*0.6, 'comet', 0.8)); }, i * 150); } }, 1200);
            setTimeout(() => { for(let i=0; i<3; i++) { const x = cx + (i-1)*200*fwScale; setTimeout(() => { particles.push(new Shell(x, fwHeight, x, fwHeight*0.3, 'willow', 1.0)); }, i*300); } }, 2000);
        }

        // ==========================================
        // PART 2: 3D ENGINE
        // ==========================================
        const CONFIG = { 
            colors: { bg: 0x050505, gold: 0xffaa00, green: 0x03180a, red: 0xff0044 }, 
            goldCount: 500, silverCount: 500, gemCount: 300, emeraldCount: 300, dustCount: 1000,
            treeHeight: 75, maxRadius: 30, 
            snow: { count: 1500, speed: 3.5 }, 
            camera: { z: 110 },
            bloomStrength: 0.7, bloomThreshold: 0.35, bloomRadius: 0.6
        };
        // FIXED: hasExpandedOnce lock
        const STATE = { mode: 'TREE', focusTarget: null, hand: { detected: false, x: 0, y: 0 }, rotation: { x: 0, y: 0 }, photoIndex: -1, hasExpandedOnce: false, interactionEnabled: false };
        let scene, camera, renderer, composer, mainGroup; 
        let clock = new THREE.Clock();
        let snowSystem;
        let handLandmarker, video, webcamCanvas, webcamCtx;
        let raycaster = new THREE.Raycaster(); let mouse = new THREE.Vector2();
        
        // 鼠标拖拽旋转相关变量
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotationY = 0;
        let targetRotationX = 0;
        const rotationSpeed = 0.002; // 旋转速度（慢一点）
        
        // 聚焦图片拖拽相关变量
        let isFocusDragging = false;
        let focusPhotoOffset = { x: 0, y: 0 };
        
        // InstancedMesh 相关
        let goldMesh, silverMesh, gemMesh, emeraldMesh, dustSystem;
        let logicData = { gold: [], silver: [], gem: [], emerald: [], dust: [], star: null };
        let photoMeshes = [];
        const dummy = new THREE.Object3D();

        window.startThreeEngine = function() {
            initThree();
            createSceneContent();
            resizeFireworks();
            setupInteraction();
            animate();
        };

        // FIXED: No loops, 1:1 photo mapping
        window.addPhotosToRunningScene = function(photos) {
            photos.forEach(photoData => {
                 addPhotoParticle(photoData.src, photoData.aspect);
            });
        };

        // FIXED: Enable interaction after setup
        window.activateInteraction = function() {
            // Add slight delay to prevent instant trigger
            setTimeout(() => {
                STATE.interactionEnabled = true;
            }, 1000);
        };

        window.initMediaPipeModule = async function(existingStream) {
            video = document.getElementById('webcam');
            webcamCanvas = document.getElementById('webcam-preview');
            webcamCtx = webcamCanvas.getContext('2d');
            webcamCanvas.width = 160; webcamCanvas.height = 120;
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                video.srcObject = existingStream;
                video.addEventListener("loadeddata", () => {
                    console.log("Hand tracking ready");
                    predictWebcam();
                });
            } catch(e) {
                console.error("MediaPipe init failed:", e);
            }
        };

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(0x050505, 0.002); 
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, CONFIG.camera.z); 
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            renderer.toneMappingExposure = 1.1; 
            container.appendChild(renderer.domElement);
            mainGroup = new THREE.Group();
            // FIXED: Raised tree position from -2.0 to -1.0 to clear text
            mainGroup.position.y = -5.0; 
            scene.add(mainGroup);
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.35; bloomPass.strength = 0.7; bloomPass.radius = 0.6;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            
            // 灯光系统 - 和ChristmasTree一样
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xffddaa, 100);
            spotLight.position.set(30, 80, 50);
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 1;
            scene.add(spotLight);

            const blueLight = new THREE.PointLight(0x4488ff, 50, 200);
            blueLight.position.set(-40, -20, 40);
            scene.add(blueLight);
        }

        function createSceneContent() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
            
            // 使用 MeshPhysicalMaterial 获得更好的金属质感
            const goldMat = new THREE.MeshPhysicalMaterial({
                color: 0xffaa00, metalness: 1.0, roughness: 0.15, clearcoat: 1.0, emissive: 0xaa5500, emissiveIntensity: 0.1
            });
            const silverMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, metalness: 0.9, roughness: 0.2, clearcoat: 1.0
            });
            const gemMat = new THREE.MeshPhysicalMaterial({
                color: 0xff0044, metalness: 0.1, roughness: 0.0, transmission: 0.6, thickness: 1.5, emissive: 0x550011, emissiveIntensity: 0.4
            });
            const emeraldMat = new THREE.MeshPhysicalMaterial({
                color: 0x00aa55, metalness: 0.2, roughness: 0.1, transmission: 0.5, thickness: 1.5, emissive: 0x002211, emissiveIntensity: 0.3
            });

            goldMesh = createInstancedMesh(new THREE.SphereGeometry(0.7, 12, 12), goldMat, CONFIG.goldCount, logicData.gold);
            silverMesh = createInstancedMesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), silverMat, CONFIG.silverCount, logicData.silver);
            gemMesh = createInstancedMesh(new THREE.OctahedronGeometry(0.8, 0), gemMat, CONFIG.gemCount, logicData.gem);
            emeraldMesh = createInstancedMesh(new THREE.ConeGeometry(0.5, 1.2, 6), emeraldMat, CONFIG.emeraldCount, logicData.emerald);

            // 树顶之星
            const starGeo = new THREE.OctahedronGeometry(3.0, 0);
            const starMat = new THREE.MeshPhysicalMaterial({ 
                color: 0xffffff, metalness:0.8, roughness:0, emissive:0xffffee, emissiveIntensity:1.5 
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.userData = { 
                treePos: new THREE.Vector3(0, CONFIG.treeHeight/2 + 2.5, 0), 
                scatterPos: new THREE.Vector3(0, 60, 0) 
            };
            star.position.copy(star.userData.treePos);
            mainGroup.add(star);
            logicData.star = star;
            
            createDust();
            createSnow();
            createStarField();
        }

        function createInstancedMesh(geo, mat, count, dataArray) {
            const mesh = new THREE.InstancedMesh(geo, mat, count);
            mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            mainGroup.add(mesh);
            
            for (let i = 0; i < count; i++) {
                const h = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
                const normH = (h + CONFIG.treeHeight/2) / CONFIG.treeHeight;
                const rMax = CONFIG.maxRadius * (1 - normH) * 1.1; 
                const r = Math.sqrt(Math.random()) * rMax; 
                const theta = Math.random() * Math.PI * 2;
                
                const treePos = new THREE.Vector3(r * Math.cos(theta), h, r * Math.sin(theta));
                const scatterPos = randomSpherePoint(40 + Math.random()*50);

                dataArray.push({
                    treePos: treePos,
                    scatterPos: scatterPos,
                    currentPos: treePos.clone(),
                    scale: 0.5 + Math.random() * 0.9,
                    rotSpeed: new THREE.Euler(Math.random()*0.02, Math.random()*0.02, 0),
                    rotation: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0)
                });
            }
            return mesh;
        }

        function randomSpherePoint(r) {
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        }

        function createDust() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.dustCount * 3);
            
            for(let i=0; i<CONFIG.dustCount; i++) {
                const h = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
                const r = Math.random() * CONFIG.maxRadius + 5;
                const theta = Math.random() * Math.PI * 2;
                const x = r*Math.cos(theta);
                const z = r*Math.sin(theta);
                pos[i*3] = x; pos[i*3+1] = h; pos[i*3+2] = z;
                
                logicData.dust.push({
                    treePos: new THREE.Vector3(x, h, z),
                    scatterPos: randomSpherePoint(70),
                    currentPos: new THREE.Vector3(x, h, z),
                    velocity: Math.random() * 0.05 + 0.02
                });
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            
            const mat = new THREE.PointsMaterial({ 
                color: 0xffd700, size: 0.5, transparent: true, opacity: 0.4, 
                blending: THREE.AdditiveBlending, depthWrite: false 
            });
            dustSystem = new THREE.Points(geo, mat);
            mainGroup.add(dustSystem);
        }

        function createStarField() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<800; i++) {
                pos.push((Math.random()-0.5)*800, (Math.random()-0.5)*800, (Math.random()-0.5)*800);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const stars = new THREE.Points(geo, new THREE.PointsMaterial({color: 0x666666, size: 1.0, transparent: true, opacity: 0.6}));
            scene.add(stars);
        }

        function addPhotoParticle(src, aspect) {
            const tex = new THREE.TextureLoader().load(src);
            tex.colorSpace = THREE.SRGBColorSpace;
            
            let w = 2.5, h = 2.5;  // 图片尺寸
            if(aspect > 1) h = 2.5 / aspect;
            else w = 2.5 * aspect;

            const geo = new THREE.PlaneGeometry(w, h);
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat);
            
            // 金色边框
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(w+0.2, h+0.2, 0.1), 
                new THREE.MeshPhysicalMaterial({color:0xffd700, roughness:0.2, metalness:1})
            );
            frame.position.z = -0.06;
            mesh.add(frame);

            // 随机分布在树上
            const h_pos = (Math.random() - 0.5) * CONFIG.treeHeight;
            const normH = (h_pos + CONFIG.treeHeight/2) / CONFIG.treeHeight;
            const maxR = CONFIG.maxRadius * (1 - normH) + 2;
            const r = maxR * (0.6 + 0.4 * Math.random());
            const theta = Math.random() * Math.PI * 2;
            
            const treePos = new THREE.Vector3(r * Math.cos(theta), h_pos, r * Math.sin(theta));
            const scatterPos = randomSpherePoint(60);

            mesh.userData = { treePos, scatterPos, baseRot: new THREE.Euler(0, theta + Math.PI/2, 0) };
            mesh.position.copy(treePos);
            mesh.lookAt(new THREE.Vector3(0, h_pos, 0));
            
            photoMeshes.push(mesh);
            mainGroup.add(mesh);
        }

        // 更新InstancedMesh的逻辑
        function updateMeshLogic(mesh, dataArray) {
            const isTree = STATE.mode === 'TREE';
            for (let i = 0; i < dataArray.length; i++) {
                const item = dataArray[i];
                let target = isTree ? item.treePos : item.scatterPos;
                
                if (!isTree) item.currentPos.y += Math.sin(clock.elapsedTime + i * 0.1) * 0.01;
                item.currentPos.lerp(target, 0.08);
                
                item.rotation.x += item.rotSpeed.x;
                item.rotation.y += item.rotSpeed.y;

                let s = item.scale;
                if (STATE.mode === 'FOCUS') s *= 0.5;

                dummy.position.copy(item.currentPos);
                dummy.rotation.copy(item.rotation);
                dummy.scale.setScalar(s);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            mesh.instanceMatrix.needsUpdate = true;
        }

        function updateDustLogic() {
            const positions = dustSystem.geometry.attributes.position.array;
            const isTree = STATE.mode === 'TREE';

            for(let i=0; i<logicData.dust.length; i++) {
                const item = logicData.dust[i];
                
                if (isTree) {
                    item.currentPos.y += item.velocity;
                    if(item.currentPos.y > CONFIG.treeHeight/2) item.currentPos.y = -CONFIG.treeHeight/2;
                    
                    const rMax = CONFIG.maxRadius * (1 - (item.currentPos.y + CONFIG.treeHeight/2)/CONFIG.treeHeight) + 5;
                    const rCurr = Math.sqrt(item.currentPos.x**2 + item.currentPos.z**2);
                    if(rCurr > rMax) {
                        item.currentPos.x *= 0.95;
                        item.currentPos.z *= 0.95;
                    }
                } else {
                    item.currentPos.lerp(item.scatterPos, 0.05);
                }

                positions[i*3] = item.currentPos.x;
                positions[i*3+1] = item.currentPos.y;
                positions[i*3+2] = item.currentPos.z;
            }
            dustSystem.geometry.attributes.position.needsUpdate = true;
        }

        function updatePhotoLogic() {
            photoMeshes.forEach((mesh, idx) => {
                let targetPos, targetScale = 1.5;  // 默认尺寸
                
                if (STATE.mode === 'FOCUS' && STATE.focusTarget === mesh) {
                    // 聚焦的图片移到scene中（不跟随mainGroup旋转）
                    if (mesh.parent === mainGroup) {
                        mainGroup.remove(mesh);
                        scene.add(mesh);
                    }
                    // 聚焦时在屏幕中间，固定不动
                    targetPos = new THREE.Vector3(focusPhotoOffset.x, focusPhotoOffset.y - 5, 60);
                    targetScale = 8.0;  // 聚焦时放大更多
                    mesh.lookAt(camera.position);
                } else {
                    // 非聚焦的图片放回mainGroup中（跟随旋转）
                    if (mesh.parent === scene) {
                        scene.remove(mesh);
                        mainGroup.add(mesh);
                    }
                    targetPos = STATE.mode === 'TREE' ? mesh.userData.treePos : mesh.userData.scatterPos;
                    if(STATE.mode !== 'TREE') {
                        mesh.position.y += Math.sin(clock.elapsedTime+idx)*0.02;
                        targetScale = 2.0;  // 散开时稍大一点
                    }
                    
                    if (STATE.mode === 'TREE') {
                        mesh.rotation.copy(mesh.userData.baseRot);
                        mesh.rotation.y += 0.01;
                    } else {
                        mesh.lookAt(camera.position);
                    }
                }
                
                mesh.position.lerp(targetPos, 0.1);
                const currentScale = mesh.scale.x;
                const newScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.1);
                mesh.scale.setScalar(newScale);
            });
        }

        function createSnow() {
            const geo = new THREE.BufferGeometry();
            const pos = []; const vel = [];
            for(let i=0; i<CONFIG.snow.count; i++) {
                pos.push((Math.random()-0.5)*200, (Math.random()-0.5)*200+10, (Math.random()-0.5)*200);
                vel.push((Math.random()-0.5)*0.5, -(Math.random()*0.5+0.5)*CONFIG.snow.speed, (Math.random()-0.5)*0.5);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.userData = { vel: vel };
            const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
            const ctx = cvs.getContext('2d');
            const gr = ctx.createRadialGradient(16,16,0,16,16,16);
            gr.addColorStop(0,'rgba(255,255,255,1)'); gr.addColorStop(1,'rgba(255,255,255,0)');
            ctx.fillStyle=gr; ctx.fillRect(0,0,32,32);
            const mat = new THREE.PointsMaterial({ size: 0.6, map: new THREE.CanvasTexture(cvs), transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, depthWrite: false });
            snowSystem = new THREE.Points(geo, mat);
            scene.add(snowSystem);
        }

        function changeState(newState) {
            if (STATE.mode === newState) return;
            
            // 烟花已取消
            if (newState === 'SCATTER') {
                STATE.hasExpandedOnce = true;
            }
            // if (newState === 'TREE' && STATE.mode === 'SCATTER' && STATE.hasExpandedOnce) {
            //      triggerChapter3Fireworks();
            // }
            
            STATE.mode = newState;
            STATE.focusTarget = null;
        }

        function setupInteraction() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
                resizeFireworks();
            });

            // 鼠标按下事件
            let clickStartTime = 0;
            let clickStartPos = { x: 0, y: 0 };
            
            const onMouseDown = (event) => {
                if (!STATE.interactionEnabled) return;
                
                const clientX = event.clientX || (event.touches && event.touches[0].clientX);
                const clientY = event.clientY || (event.touches && event.touches[0].clientY);
                
                clickStartTime = Date.now();
                clickStartPos = { x: clientX, y: clientY };
                
                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                
                if (STATE.mode === 'FOCUS') {
                    // 聚焦模式下，检测是否点击了聚焦的图片，开始拖拽
                    const intersects = raycaster.intersectObjects([STATE.focusTarget], true);
                    if (intersects.length > 0) {
                        isFocusDragging = true;
                        previousMousePosition = { x: clientX, y: clientY };
                        return;
                    }
                    // 点击其他地方退出聚焦
                    changeState('SCATTER');
                    focusPhotoOffset = { x: 0, y: 0 };
                    return;
                }
                
                if (STATE.mode === 'TREE') {
                    // TREE模式下也支持拖拽旋转
                    isDragging = true;
                    previousMousePosition = { x: clientX, y: clientY };
                } else if (STATE.mode === 'SCATTER') {
                    // 检测是否点击了照片
                    const intersects = raycaster.intersectObjects(photoMeshes, true);
                    if (intersects.length > 0) {
                        let obj = intersects[0].object;
                        while(obj.parent && !photoMeshes.includes(obj)) obj = obj.parent;
                        if (photoMeshes.includes(obj)) {
                            STATE.mode = 'FOCUS';
                            STATE.focusTarget = obj;
                            STATE.photoIndex = photoMeshes.indexOf(obj);
                            focusPhotoOffset = { x: 0, y: 0 };  // 重置偏移
                            return;
                        }
                    }
                    // 开始拖拽旋转（但不立即切换状态）
                    isDragging = true;
                    previousMousePosition = { x: clientX, y: clientY };
                }
            };
            
            // 鼠标移动事件
            const onMouseMove = (event) => {
                if (!STATE.interactionEnabled) return;
                
                const clientX = event.clientX || (event.touches && event.touches[0].clientX);
                const clientY = event.clientY || (event.touches && event.touches[0].clientY);
                
                if (isFocusDragging && STATE.mode === 'FOCUS') {
                    // 拖拽聚焦的图片
                    const deltaX = (clientX - previousMousePosition.x) * 0.1;
                    const deltaY = -(clientY - previousMousePosition.y) * 0.1;
                    focusPhotoOffset.x += deltaX;
                    focusPhotoOffset.y += deltaY;
                    previousMousePosition = { x: clientX, y: clientY };
                } else if (isDragging && (STATE.mode === 'SCATTER' || STATE.mode === 'TREE')) {
                    // 拖拽旋转场景
                    const deltaX = clientX - previousMousePosition.x;
                    const deltaY = clientY - previousMousePosition.y;
                    
                    targetRotationY += deltaX * rotationSpeed;
                    targetRotationX += deltaY * rotationSpeed;
                    
                    // 限制X轴旋转角度
                    targetRotationX = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, targetRotationX));
                    
                    previousMousePosition = { x: clientX, y: clientY };
                }
            };
            
            // 鼠标松开事件
            const onMouseUp = (event) => {
                // 判断是否是点击（短时间内没有移动太多）
                const clientX = event.clientX || (event.changedTouches && event.changedTouches[0].clientX) || clickStartPos.x;
                const clientY = event.clientY || (event.changedTouches && event.changedTouches[0].clientY) || clickStartPos.y;
                const timeDiff = Date.now() - clickStartTime;
                const distMoved = Math.sqrt(Math.pow(clientX - clickStartPos.x, 2) + Math.pow(clientY - clickStartPos.y, 2));
                
                // 如果是短点击（<300ms）且移动距离小（<10px）
                if (timeDiff < 300 && distMoved < 10 && !isFocusDragging) {
                    if (STATE.mode === 'SCATTER') {
                        changeState('TREE');
                    } else if (STATE.mode === 'TREE') {
                        changeState('SCATTER');
                    }
                }
                
                isDragging = false;
                isFocusDragging = false;
            };
            
            // 点击事件（已废弃，用onMouseUp处理）
            const onClick = (event) => {
                // 不再使用
            };
            
            // 绑定事件
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('mouseleave', onMouseUp);
            
            // 触摸事件 - 只在canvas上阻止默认行为，不影响按钮点击
            const canvas = renderer.domElement;
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                onMouseDown(e);
            }, {passive: false});
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                onMouseMove(e);
            }, {passive: false});
            canvas.addEventListener('touchend', onMouseUp, {passive: false});
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (handLandmarker) {
                    const result = handLandmarker.detectForVideo(video, performance.now());
                    if (result.landmarks && result.landmarks.length > 0) {
                        if (!STATE.interactionEnabled) {
                            requestAnimationFrame(predictWebcam);
                            return;
                        }

                        STATE.hand.detected = true;
                        const landmarks = result.landmarks[0];
                        
                        // 计算手掌中心位置
                        const palmX = 1 - (landmarks[0].x + landmarks[9].x) / 2;
                        const palmY = (landmarks[0].y + landmarks[9].y) / 2;
                        STATE.hand.x = (palmX - 0.5) * 2;
                        STATE.hand.y = (palmY - 0.5) * 2;

                        // 更精确的手势判定
                        let folded = 0;
                        const tips = [8, 12, 16, 20];
                        tips.forEach(tipIdx => {
                            const d = Math.sqrt(
                                Math.pow(landmarks[tipIdx].x - landmarks[0].x, 2) +
                                Math.pow(landmarks[tipIdx].y - landmarks[0].y, 2)
                            );
                            if (d < 0.25) folded++;
                        });

                        const pinchDist = Math.sqrt(
                            Math.pow(landmarks[4].x - landmarks[8].x, 2) +
                            Math.pow(landmarks[4].y - landmarks[8].y, 2)
                        );

                        const isPinch = pinchDist < 0.08;
                        const isFist = folded >= 3;
                        const isOpen = !isFist && !isPinch;

                        if (STATE.mode === 'FOCUS') {
                            if (!isPinch) changeState('SCATTER');
                        } else {
                            if (isPinch && photoMeshes.length > 0) {
                                STATE.mode = 'FOCUS';
                                STATE.photoIndex = (STATE.photoIndex + 1) % photoMeshes.length;
                                STATE.focusTarget = photoMeshes[STATE.photoIndex];
                            } else if (isFist) {
                                changeState('TREE');
                            } else if (isOpen) {
                                changeState('SCATTER');
                            }
                        }
                    } else {
                        STATE.hand.detected = false;
                    }
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            
            // 烟花渲染
            fwCtx.clearRect(0, 0, fwWidth, fwHeight);
            fwCtx.globalCompositeOperation = 'lighter';
            let sIdx = smokes.length; while(sIdx--) { if(!smokes[sIdx].update()) smokes.splice(sIdx, 1); else smokes[sIdx].draw(); }
            let pIdx = particles.length; while(pIdx--) { if(!particles[pIdx].update()) particles.splice(pIdx, 1); else particles[pIdx].draw(); }
            
            // 更新InstancedMesh
            updateMeshLogic(goldMesh, logicData.gold);
            updateMeshLogic(silverMesh, logicData.silver);
            updateMeshLogic(gemMesh, logicData.gem);
            updateMeshLogic(emeraldMesh, logicData.emerald);
            
            // 更新尘埃和照片
            updateDustLogic();
            updatePhotoLogic();
            
            // 更新树顶星
            if (logicData.star) {
                let target = STATE.mode === 'TREE' ? logicData.star.userData.treePos : logicData.star.userData.scatterPos;
                logicData.star.position.lerp(target, 0.05);
                logicData.star.rotation.y += 0.01;
            }
            
            // 雪花
            if (snowSystem) {
                const pos = snowSystem.geometry.attributes.position.array;
                const vel = snowSystem.geometry.userData.vel;
                for(let i=0; i<CONFIG.snow.count; i++) {
                    pos[i*3+1] += vel[i*3+1] * dt * 5.0; 
                    pos[i*3] += Math.sin(clock.elapsedTime+i)*0.02;
                    if(pos[i*3+1] < -60) pos[i*3+1] = 100;
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // 旋转控制
            if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
                const tx = STATE.hand.y * Math.PI * 0.25; const ty = STATE.hand.x * Math.PI * 0.9;
                STATE.rotation.x += (tx - STATE.rotation.x) * 3 * dt; STATE.rotation.y += (ty - STATE.rotation.y) * 3 * dt;
            } else if ((STATE.mode === 'SCATTER' || STATE.mode === 'TREE') && isDragging) {
                // 拖拽时直接应用目标旋转
                STATE.rotation.y += (targetRotationY - STATE.rotation.y) * 0.1;
                STATE.rotation.x += (targetRotationX - STATE.rotation.x) * 0.1;
            } else {
                // 所有模式下都自动旋转（包括FOCUS）
                STATE.rotation.y += 0.3 * dt;
                if (STATE.mode === 'TREE') {
                    STATE.rotation.x *= 0.95;
                }
            }
            mainGroup.rotation.x = STATE.rotation.x; mainGroup.rotation.y = STATE.rotation.y;
            
            composer.render();
        }
    </script>
</body>
</html>